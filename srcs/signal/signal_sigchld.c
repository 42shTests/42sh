#include "shell.h"

/*
** This function catches the signal SIGCHLD that is generated by each child
** process launched within the function `launch_job`.
** SIGCHLD is received when a process:
** - has terminated
** - is stopped by receiving the signal SIGTSTP
** This function does:
** - save the status of the process (completed or stopped)
** - check the status of the whole job
** - notify the user if the job is completed or stopped
** - free the job when completed
*/

static void	s_job_notification (void)
{
	t_job	*j;
	t_list	*pos;
	t_list	*safe;
	t_list	*head;

	head = &g_current_jobs_list_head;
	safe = head->next;
	while((pos = safe) && pos != head)
	{
		safe = safe->next;
		j = CONTAINER_OF(pos, t_job, list_job);
		if (job_is_completed(j) == 1)
		{
			// check if it is a background job
			// and warn user about its status
			//if (is_job_stopped(j) == 1 || j->foreground == 0)
			//{
			//	display a message "job completed"
			//	reinit_prompt();
			//}

			// remove job from list of current jobs
			list_del(pos);
		}
		// else Ctrl + Z
		//else if (is_job_stopped(j) == 1 && j->notified == 0)
		//{
		//	format_job_info (j, "stopped");
		//	j->notified = 1;
		//}
	}
}

void	signal_sigchld(int sig)
{
	int		status;
	pid_t	pid;

	log_debug("SIGCHLD received");
	if (sig == SIGCHLD)
	{
		errno = 0;
		while (1)
		{
			pid = waitpid(WAIT_ANY, &status, WUNTRACED | WNOHANG);
			if (proc_update_status(pid, status) == 0)
				break ;
		}
		s_job_notification();
	}
}
